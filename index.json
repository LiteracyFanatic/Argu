[{"uri":"http://fsprojects.github.io/Argu/index.html","title":"Introduction\r\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#I \"../src/Argu/bin/Release/netstandard2.0\"\n#r \"Argu.dll\"\n\nopen System\nopen Argu\n\ntype Args =\n    | Working_Directory of path:string\n    | Listener of host:string * port:int\n    | Log_Level of level:int\n    | Detach\nwith\n    interface IArgParserTemplate with\n        member __.Usage = \"\"\n\n(**\n\n# Introduction\n\nArgu (pronounced \"Argue\") is a declarative CLI argument parser for F# console applications.\nIt allows modelling the command-line syntax using discriminated unions,\nwhich the library converts into a working parser using reflection.\n\nArgu is a mature library that comes with many features\n\n  * Declarative: easily model your syntax definitions using F# unions.\n  * Convenient: automatic derivation of CLI syntax and documentation.\n  * Customizable: control most aspects of your parser behaviour.\n  * Subcommands: use contextual syntax with nested argument schemata.\n\nIt can be installed using <a href=\"https://nuget.org/packages/Argu\">NuGet</a>.\n\n## Basic Concepts\n\nThe library is based on the simple observation that \nconfiguration parameters can be naturally described using discriminated unions. \nFor instance:\n\n*)\n\ntype Arguments =\n    | Working_Directory of path:string\n    | Listener of host:string * port:int\n    | Log_Level of level:int\n    | Detach\n\n(**\n\nArgu takes such discriminated unions and generates \na corresponding argument parsing scheme. \nFor example, a parser generated from the above template would\ntake the following command line input\n\n    [lang=bash]\n    --working-directory /var/run --listener localhost 8080 --detach\n\nand parse it into the list\n*)\n\n[ Working_Directory \"/var/run\" ; Listener(\"localhost\", 8080) ; Detach ]\n\n(**\n\nArgu is also capable of reading the `AppSettings` section\nof an application's configuration file:\n\n    [lang=xml]\n    <appSettings>\n        <add key=\"working directory\" value=\"C:\\temp\" />\n        <add key=\"listener\" value=\"192.168.0.3, 2675\" />\n        <add key=\"log level\" value=\"3\" />\n        <add key=\"detach\" value=\"true\" />\n    </appSettings>\n\nFurthermore, you can parse environment variables, by supplying the an `EnvironmentVariableReader` to the `Parse` call:\n*)\n\nlet argv = [| \"--log-level\"; \"3\" |]\nlet reader = EnvironmentVariableConfigurationReader() :> IConfigurationReader\nlet parser =  ArgumentParser.Create<Args>(programName = \"rutta\")\n// pass the reader to the Parse call\nlet results = parser.Parse(argv, configurationReader=reader)\n\n(**\n## Who uses Argu?\n\n  * [MBrace](http://m-brace.net/)\n  \n  * [FAKE](http://fsharp.github.io/FAKE/)\n  \n  * [Paket](http://fsprojects.github.io/Paket/)\n  \n  * [Logary](https://logary.tech)\n\n## Documentation\n\n  * [Tutorial](tutorial.html) A short walkthrough of Argu features.\n\n  * [API Reference](reference/index.html) contains automatically generated documentation for all types, \n    modules and functions in the library.\n\n## Contributing and copyright\n\nThe project is hosted on [GitHub][gh] where you can [report issues][issues], fork \nthe project and submit pull requests.\n\nThe library is available under the MIT License. \nFor more information see the [License file][license] in the GitHub repository. \n\n  [gh]: https://github.com/fsprojects/Argu\n  [issues]: https://github.com/fsprojects/Argu/issues\n  [license]: https://github.com/fsprojects/Argu/blob/master/License.md\n\n*)"},{"uri":"http://fsprojects.github.io/Argu/perf.html","title":"Performance Tips\r\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use\n// it to define helpers that you do not want to show in the documentation.\n#I \"../src/Argu/bin/Release/netstandard2.0\"\n#r \"Argu.dll\"\n\nopen Argu\n\ntype Arguments =\n    | Argument\nwith\n    interface IArgParserTemplate with\n        member __.Usage =\n            \"Usage\"\n\ntype FactAttribute () = inherit System.Attribute()\n\n(**\n\n# Performance Tips\n\n## Introduction\n\nArgu simplicity is achieved via Reflection and as such it's performance heavily depend on the size and depth of the\ndiscriminated union used.\n\nFor applications that wants to get a little more performance out of Argu it's also possible to get a little more\nperformance.\n\n## Bypassing structure checks\n\nBy default Argu checks that the discriminated union is well formed and only contains entries that are valid.\nThis incur both the cost of the checks themselves but also the cost of materializing the whole argument graph that could\nbe loaded only if the corresponding arguments are used.\n\nThis check can easilly be bypassed either only in release builds :\n\n*)\n\nlet checkStructure =\n#if DEBUG\n    true\n#else\n    false\n#endif\n\nlet parser = ArgumentParser.Create<Arguments>(checkStructure = checkStructure)\n\n(**\n\nOr always, forcing the check to happen during unit tests:\n\n*)\n\n// In the application\nmodule AppArgs =\n    let parser = ArgumentParser.Create<Arguments>(checkStructure = false)\n\n// In tests\n[<Fact>]\nlet ``Argument structure is correct`` () =\n    ArgumentParser<Arguments>.CheckStructure()\n(**\n*)"},{"uri":"http://fsprojects.github.io/Argu/tutorial.html","title":"Tutorial\r\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use\n// it to define helpers that you do not want to show in the documentation.\n#I \"../src/Argu/bin/Release/netstandard2.0\"\n#r \"Argu.dll\"\n\nopen System\n\n(**\n\n# Tutorial\n\n## Introduction\n\nThe library is based on the simple observation that\nconfiguration parameters can be naturally described using discriminated unions.\nFor instance:\n\n*)\n\ntype Arguments =\n    | Working_Directory of path:string\n    | Listener of host:string * port:int\n    | Log_Level of level:int\n    | Detach\n\n(**\n\nArgu takes such discriminated unions and generates\na corresponding argument parsing scheme.\nFor example, a parser generated from the above template would\ntake the following command line input\n\n    [lang=bash]\n    --working-directory /var/run --listener localhost 8080 --detach\n\nand parse it into the list\n*)\n\n[ Working_Directory \"/var/run\" ; Listener(\"localhost\", 8080) ; Detach ]\n\n(**\n\nArgu is also capable of reading the `AppSettings` section\nof an application's configuration file:\n\n    [lang=xml]\n    <appSettings>\n        <add key=\"working directory\" value=\"C:\\temp\" />\n        <add key=\"listener\" value=\"192.168.0.3, 2675\" />\n        <add key=\"log level\" value=\"3\" />\n        <add key=\"detach\" value=\"true\" />\n    </appSettings>\n\nBoth XML configuration and command line arguments can be parsed\nat the same time. By default, command line parameters override\ntheir corresponding XML configuration.\n\n## Basic Usage\n\nA minimal parser based on the above example can be created as follows:\n*)\n\nopen Argu\n\ntype CliArguments =\n    | Working_Directory of path:string\n    | Listener of host:string * port:int\n    | Data of base64:byte[]\n    | Port of tcp_port:int\n    | Log_Level of level:int\n    | Detach\n\n    interface IArgParserTemplate with\n        member s.Usage =\n            match s with\n            | Working_Directory _ -> \"specify a working directory.\"\n            | Listener _ -> \"specify a listener (hostname : port).\"\n            | Data _ -> \"binary data in base64 encoding.\"\n            | Port _ -> \"specify a primary port.\"\n            | Log_Level _ -> \"set the log level.\"\n            | Detach _ -> \"detach daemon from console.\"\n\n(** We extract the argument parser from the template using the following command: *)\n\nlet parser = ArgumentParser.Create<CliArguments>(programName = \"gadget.exe\")\n\n(** We can get the automatically generated usage string by typing *)\n\nlet usage = parser.PrintUsage()\n\n(** giving\n\n    [lang=bash]\n    USAGE: gadget.exe [--help] [--working-directory <path>] [--listener <host> <port>] [--data <base64>]\n                      [--port <tcp port>] [--log-level <level>] [--detach]\n\n    OPTIONS:\n\n        --working-directory <path>\n                              specify a working directory.\n        --listener <host> <port>\n                              specify a listener (hostname : port).\n        --data <base64>       binary data in base64 encoding.\n        --port <tcp port>     specify a primary port.\n        --log-level <level>   set the log level.\n        --detach              detach daemon from console.\n        --help                display this list of options.\n\nTo parse a command line input:\n\n*)\n\nlet results = parser.Parse [| \"--detach\" ; \"--listener\" ; \"localhost\" ; \"8080\" |]\n\n(** which gives *)\n\nlet all = results.GetAllResults() // [ Detach ; Listener (\"localhost\", 8080) ]\n\n(**\n\n## Querying Parameters\n\nWhile getting a single list of all parsed results might be useful for some cases,\nit is more likely that you need to query the results for specific parameters:\n\n*)\n\nlet detach = results.Contains Detach\nlet listener = results.GetResults Listener\n\n(** The following methods return the last observed result for given argument case *)\n\nlet dataOpt = results.TryGetResult Data\nlet logLevel = results.GetResult (Log_Level, defaultValue = 0)\n\n(**\n\nQuerying using quotations enables a simple and type safe way\nto deconstruct parse results into their constituent values.\n\n## Customization\n\nThe parsing behaviour of the configuration parameters\ncan be customized by fixing attributes to the union cases:\n\n*)\n\ntype Argument =\n    | [<Mandatory>] Cache_Path of path:string\n    | [<NoCommandLine>] Connection_String of conn:string\n    | [<Unique>] Listener of host:string * port:int\n    | [<EqualsAssignment>] Assignment of value:string\n    | [<EqualsAssignmentOrSpaced>] AssignmentOrSpace of value:string\n    | [<AltCommandLine(\"-p\")>] Primary_Port of tcp_port:int\n\n(**\n\nIn this case,\n\n  * [`Mandatory`](reference/argu-arguattributes-mandatoryattribute.html): parser will fail if no configuration for this parameter is given.\n\n  * [`NoCommandLine`](reference/argu-arguattributes-nocommandlineattribute.html): restricts this parameter to the AppSettings section.\n\n  * [`AltCommandLine`](reference/argu-arguattributes-altcommandlineattribute.html): specifies an alternative command line switch.\n\n  * [`EqualsAssignment`](reference/argu-arguattributes-equalsassignmentattribute.html) : enforces `--assignment=value` and `--assignment key=value` CLI syntax.\n  \n  * [`EqualsAssignmentOrSpaced`](reference/argu-arguattributes-equalsassignmentorspacedattribute.html) : enforces `--assignment=value` and `--assignment value` CLI syntax.\n\n  * [`Unique`](reference/argu-arguattributes-uniqueattribute.html) : parser will fail if CLI provides this argument more than once.\n\nMany more attributes are also available, such as\n\n  * [`First`](reference/argu-arguattributes-firstattribute.html): Argument can only be placed at the beginning of the command line.\n\n  * [`Hidden`](reference/argu-arguattributes-hiddenattribute.html): do not display in the help usage string.\n\n  * [`CustomAppSettings`](reference/argu-arguattributes-customappsettingsattribute.html): sets a custom key name for AppSettings.\n\n  * [`CustomAssignment`](reference/argu-arguattributes-customassignmentattribute.html): works like EqualsAssignment but with a custom separator string.\n\nPlease see the [API Reference](http://fsprojects.github.io/Argu/reference/argu-arguattributes.html)\nfor a complete list of all attributes provided by Argu.\n\n## Supported Primitives\n\nArguments can specify the following primitives as parameters:\n\n  * `bool`, `byte` and `sbyte`.\n  * `int`, `int16` and `int64`.\n  * `uint`, `uint16` and `uint64`.\n  * `char`, `string` and `guid`.\n  * `float`, `double` and `decimal`.\n  * `System.Numerics.BigInt`.\n  * `byte[]`, which accepts base64 representations.\n\n## Optional and List parameters\n\nAdditionally, it is possible to specify argument parameters that are either optional or lists:\n\n*)\n\ntype VariadicParameters =\n    | [<EqualsAssignment>] Enable_Logging of path:string option\n    | Tcp_Ports of port:int list\n\n(**\n\nwhich results in the following syntax:\n\n    [lang=console]\n    USAGE: gadget.exe [--help] [--enable-logging[=<path>]] [--tcp-ports [<port>...]]\n\n    OPTIONS:\n\n        --enable-logging[=<path>]  enable logging for the process; optionally path to the logfile can be specified.\n        --tcp-ports [<port>...]    specify a list of TCP ports for the process.\n        --help                     display this list of options.\n\nNote that arguments that use optional or list must have precisely one parameter.\n\n## Enumeration parameters\n\nArgu can also accept enumerations as parameters:\n\n*)\n\ntype MyEnum =\n    | First  = 1\n    | Second = 2\n    | Third  = 3\n\ntype EnumArguments =\n    | Get_Enum of MyEnum\n\n(**\n\nwhich results in the syntax\n\n    [lang=console]\n    USAGE: gadget.exe [--help] [--get-enum <first|second|third>]\n\n    OPTIONS:\n\n        --get-enum <first|second|third>\n                              specify either of 'first', 'second' or 'third'.\n        --help                display this list of options.\n\nNote that it is possible to specify F# unions instead of enumerations in this context,\nprovided that these do not specify any parameters in any of their cases.\n\n## Main commands\n\nArguments carrying the [MainCommand](reference/argu-arguattributes-maincommandattribute.html)\nattribute can be used to specify the main set of arguments for the CLI.\nThese arguments can be passed without the need to specify a switch identifier.\n\n*)\n\ntype WGetArguments =\n    | Quiet\n    | No_Check_Certificate\n    | [<MainCommand; ExactlyOnce; Last>] Urls of url:string list\n\n(**\n\nwhich generates the syntax\n\n    [lang=console]\n    USAGE: wget [--help] [--quiet] [--no-check-certificate] <url>...\n\n    URLS:\n\n        <url>...              List of urls to download from.\n\n    OPTIONS:\n\n        --quiet               Turn off Wget's output.\n        --no-check-certificate\n                              Don't check the server certificate.\n        --help                display this list of options.\n\n## SubCommands\n\nAs of Argu 3.0, it is possible to provide nested, contextual parsing.\nFor example, consider this mock git CLI syntax:\n\n*)\n\n[<CliPrefix(CliPrefix.Dash)>]\ntype CleanArgs =\n    | D\n    | F\n    | X\n\n    interface IArgParserTemplate with\n        member this.Usage =\n            match this with\n            | D -> \"Remove untracked directories in addition to untracked files\"\n            | F -> \"Git clean will refuse to delete files or directories unless given -f.\"\n            | X -> \"Remove only files ignored by Git.\"\n\n(** *)\n\nand CommitArgs =\n    | Amend\n    | [<AltCommandLine(\"-p\")>] Patch\n    | [<AltCommandLine(\"-m\")>] Message of msg:string\n\n    interface IArgParserTemplate with\n        member this.Usage =\n            match this with\n            | Amend -> \"Replace the tip of the current branch by creating a new commit.\"\n            | Patch -> \"Use the interactive patch selection interface to chose which changes to commit.\"\n            | Message _ -> \"Use the given <msg> as the commit message. \"\n\n(** *)\n\nand GitArgs =\n    | Version\n    | [<AltCommandLine(\"-v\")>] Verbose\n    | [<CliPrefix(CliPrefix.None)>] Clean of ParseResults<CleanArgs>\n    | [<CliPrefix(CliPrefix.None)>] Commit of ParseResults<CommitArgs>\n\n    interface IArgParserTemplate with\n        member this.Usage =\n            match this with\n            | Version -> \"Prints the Git suite version that the git program came from.\"\n            | Verbose -> \"Print a lot of output to stdout.\"\n            | Clean _ -> \"Remove untracked files from the working tree.\"\n            | Commit _ -> \"Record changes to the repository.\"\n\n(**\nand the following console app entrypoint\n*)\n\n//[<EntryPoint>]\nlet main argv =\n    try\n        parser.ParseCommandLine(inputs = argv, raiseOnUsage = true) |> ignore\n    with e ->\n        printfn \"%s\" e.Message\n    0\n\n(**\n\nwhich generates the following syntax on corresponding command and subcommand help requests:\n\n    [lang=console]\n    USAGE: git [--help] [--version] [--verbose] [<subcommand> [<options>]]\n\n    SUBCOMMANDS:\n\n        clean <options>       Remove untracked files from the working tree.\n        commit <options>      Record changes to the repository.\n\n\t    Use 'git <subcommand> --help' for additional information.\n\n    OPTIONS:\n\n        --version             Prints the Git suite version that the git program came from.\n        --verbose, -v         Print a lot of output to stdout.\n        --help                display this list of options.\n\nand for the subcommand:\n\n    [lang=console]\n    USAGE: git commit [--help] [--amend] [--patch] [--message <msg>]\n\n    OPTIONS:\n\n        --amend               Replace the tip of the current branch by creating a new commit.\n        --patch, -p           Use the interactive patch selection interface to chose which changes to commit.\n        --message, -m <msg>   Use the given <msg> as the commit message.\n        --help                display this list of options.\n\nThis allows specifying parameters that are particular to a subcommand context.\nFor instance, `git clean -fdx` parses correctly to `[Clean [F; D; X]]`, however\n`git -f` or `git commit -f` will both result in a parse error:\n\n    [lang=console]\n    ERROR: unrecognized argument: '-f'.\n\n### Inheriting parent arguments\n\nSwitches specified in the parent argument union do not automatically\nmake it to the syntax of the child subcommand. For example the command\n\n    [lang=console]\n    git clean --version\n\nwill result in parse error since `Version` is not a part of the subcommand syntax,\nbut one of its parent syntax. It is possible to parent options visible inside subcommands\nby attaching the [`InheritAttribute`](http://fsprojects.github.io/Argu/reference/argu-arguattributes-inheritattribute.html)\nto switches.\n\n    [lang=fsharp]\n    type GitArgs =\n        | [<Inherit>] Version\n\nwhich would make the aforementioned syntax valid.\n\n## Post Processing\n\nIt should be noted here that arbitrary unions are not supported by the parser.\nUnion cases can only contain fields of primitive types. This means that user-defined\nparsers are not supported. For configuration inputs that are non-trivial,\na post-process facility is provided.\n*)\n\nlet parsePort p =\n    if p < 0 || p > int UInt16.MaxValue then\n        failwith \"invalid port number.\"\n    else p\n\nlet ports = results.PostProcessResults (<@ Port @>, parsePort)\n\n(**\n\nThis construct is useful since error handling is delegated to the mechanisms of Argu.\n\n## Unparsing Support\n\nArgu is convenient when it comes to automated process spawning:\n*)\n\nopen System.Diagnostics\n\nlet arguments = parser.PrintCommandLineArgumentsFlat [ Port 42 ; Working_Directory \"temp\" ]\n\nProcess.Start(\"foo.exe\", arguments)\n\n(**\nIt can also be used to auto-generate a suitable `AppSettings` configuration file:\n*)\n\nlet xml = parser.PrintAppSettingsArguments [ Port 42 ; Working_Directory \"/tmp\" ]\n\n(**\nwhich would yield the following:\n\n    [lang=xml]\n    <?xml version=\"1.0\" encoding=\"utf-16\"?>\n    <configuration>\n      <appSettings>\n        <!-- sets the port number. : port -->\n        <add key=\"port\" value=\"42\" />\n        <!-- sets the working directory. : path -->\n        <add key=\"working directory\" value=\"/tmp\" />\n      </appSettings>\n    </configuration>\n\n## More Examples\n\nCheck out the [samples](https://github.com/fsprojects/Argu/tree/master/samples)\nfolder for CLI implementations that use Argu.\n\n*)"}]